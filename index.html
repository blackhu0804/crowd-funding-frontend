<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>玻璃彩边立方体（import map 修复）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui,monospace; }
  #info {
    position:fixed; top:8px; left:10px; z-index:10; color:#9fd; font:12px/1.3 monospace;
    background:rgba(0,0,0,.35); padding:6px 10px; border:1px solid #10333f; border-radius:6px;
    backdrop-filter:blur(6px);
  }
</style>
<!-- 一定要在你的 module 脚本之前 -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="info">玻璃彩边立方体 - 轻量版 (Fresnel + transmission)</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// 下面全部与你原代码一致（仅把 import 改成了裸模块名字）。为节省篇幅我只保留与问题无关的逻辑简写。
// === 你的原始代码开始 ===

// 基础
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(3.2, 2.4, 5.2);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// 星点
function createStars(count=300, radius=50) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for (let i=0;i<count;i++){
    const r = radius*(0.5+Math.random()*0.5);
    const theta = Math.random()*Math.PI*2;
    const u = Math.random()*2-1;
    const phi = Math.acos(u);
    pos[i*3]   = r*Math.sin(phi)*Math.cos(theta);
    pos[i*3+1] = r*Math.cos(phi)*0.3;
    pos[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({
    size:0.25, color:0x99bbdd, transparent:true,
    blending:THREE.AdditiveBlending, depthWrite:false
  });
  const pts = new THREE.Points(geo,mat);
  scene.add(pts);
  return pts;
}
const stars = createStars();

function createArcLines(n=4){
  const g = new THREE.Group();
  for (let i=0;i<n;i++){
    const r = 6 + i*0.85;
    const pts = [];
    for (let a=-0.5;a<=0.6;a+=0.02){
      pts.push(new THREE.Vector3(Math.cos(a)*r,(i-1.5)*0.05,Math.sin(a)*r));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color:0x22313d, transparent:true, opacity:0.33 });
    g.add(new THREE.Line(geo,mat));
  }
  scene.add(g);
  return g;
}
createArcLines();

// 玻璃材质 + Fresnel
const glassMat = new THREE.MeshPhysicalMaterial({
  roughness:0.18, metalness:0, transmission:1, thickness:0.85,
  ior:1.12, attenuationColor:new THREE.Color(0x0b1319), attenuationDistance:1.6,
  clearcoat:1, clearcoatRoughness:0.06, envMapIntensity:1, transparent:true, opacity:0.96
});
const fresnelUniforms = {
  uTime:{value:0},
  uEdgeColorA:{value:new THREE.Color(0x6ec9ff)},
  uEdgeColorB:{value:new THREE.Color(0xff6acb)},
  uEdgeStrength:{value:1.0},
  uEdgePower:{value:3.2},
  uRainbow:{value:0.25}
};
glassMat.onBeforeCompile = sh=>{
  Object.assign(sh.uniforms, fresnelUniforms);
  sh.fragmentShader = sh.fragmentShader
    .replace('#include <common>',`
      #include <common>
      uniform float uTime;
      uniform vec3 uEdgeColorA;
      uniform vec3 uEdgeColorB;
      uniform float uEdgeStrength;
      uniform float uEdgePower;
      uniform float uRainbow;
    `)
    .replace('#include <dithering_fragment>',`
      vec3 N = geometryNormal;
      vec3 V = normalize(vViewPosition*-1.0);
      float fres = pow(1.0 - max(dot(N,V),0.0), uEdgePower);
      fres += sin(uTime*0.6 + vViewPosition.x*5.0)*0.01;
      fres = clamp(fres,0.0,1.0);
      vec3 edgeCol = mix(uEdgeColorA,uEdgeColorB,fres);
      vec3 rainbow = normalize(vec3(fres,pow(fres,1.7),pow(fres,2.5)));
      edgeCol = mix(edgeCol,rainbow,uRainbow);
      totalEmissiveRadiance += edgeCol * fres * (uEdgeStrength * 0.55);
      #include <dithering_fragment>
    `);
};

const cube = new THREE.Mesh(new RoundedBoxGeometry(2,2,2,5,0.12), glassMat);
scene.add(cube);
cube.add(new THREE.LineSegments(
  new THREE.EdgesGeometry(new RoundedBoxGeometry(2,2,2,5,0.12)),
  new THREE.LineBasicMaterial({color:0x88ccee,transparent:true,opacity:0.18})
));

// 内部结构
function createInnerFrame(){
  const g=new THREE.Group();
  const m=new THREE.MeshBasicMaterial({color:0x6faeff,transparent:true,opacity:0.28,blending:THREE.AdditiveBlending,depthWrite:false});
  [[1.85,0.07,0.07],[0.07,1.85,0.07],[0.07,0.07,1.85]].forEach(s=>g.add(new THREE.Mesh(new THREE.BoxGeometry(...s),m)));
  const diag=new THREE.Mesh(new THREE.BoxGeometry(1.85,0.06,0.06),m.clone());
  diag.material.opacity=0.18;
  diag.rotation.set(Math.PI/4,Math.PI/4,0);
  g.add(diag);
  return g;
}
const innerFrame=createInnerFrame(); cube.add(innerFrame);

function createGlints(count=6){
  const g=new THREE.Group();
  for(let i=0;i<count;i++){
    const w=THREE.MathUtils.lerp(0.08,0.22,Math.random());
    const h=THREE.MathUtils.lerp(0.02,0.05,Math.random());
    const mesh=new THREE.Mesh(
      new THREE.PlaneGeometry(w,h),
      new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.75,blending:THREE.AdditiveBlending,depthWrite:false})
    );
    mesh.position.set((Math.random()-0.5)*1.3,(Math.random()-0.5)*1.3,(Math.random()-0.5)*1.3);
    mesh.userData.speed=0.15+Math.random()*0.25;
    mesh.userData.axis=new THREE.Vector3(Math.random(),Math.random(),Math.random()).normalize();
    g.add(mesh);
  }
  return g;
}
const glints = createGlints();
cube.add(glints);

// 环境贴图（程序化渐变）
const envTex = (() => {
  const c=document.createElement('canvas'); c.width=c.height=128;
  const ctx=c.getContext('2d');
  const g=ctx.createLinearGradient(0,0,128,128);
  g.addColorStop(0,'#1d2730'); g.addColorStop(1,'#050709');
  ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
  const t=new THREE.CanvasTexture(c);
  t.mapping=THREE.EquirectangularReflectionMapping;
  return t;
})();
scene.environment = envTex;

// 灯光
scene.add(new THREE.AmbientLight(0xffffff,0.18));
const pointLight = new THREE.PointLight(0x88ccff,25,30);
pointLight.position.set(5,5,5); scene.add(pointLight);

// 后期
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene,camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.55, 0.35, 0.18);
composer.addPass(bloom);

// Resize
addEventListener('resize',()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  composer.setSize(innerWidth, innerHeight);
});

// 动画
let t=0;
function animate(){
  requestAnimationFrame(animate);
  t += 0.016;
  fresnelUniforms.uTime.value = t;
  cube.rotation.y = t*0.22;
  cube.rotation.x = Math.sin(t*0.17)*0.18;
  cube.rotation.z = Math.sin(t*0.11)*0.05;
  innerFrame.scale.setScalar(1+Math.sin(t*0.9)*0.015);
  glints.children.forEach((m,i)=>{
    m.position.addScaledVector(m.userData.axis, m.userData.speed*0.0015);
    m.position.clamp(new THREE.Vector3(-0.95,-0.95,-0.95), new THREE.Vector3(0.95,0.95,0.95));
    m.lookAt(camera.position);
    m.material.opacity = 0.25 + Math.sin(t*1.8 + i)*0.45;
  });
  stars.rotation.y += 0.00012;
  controls.update();
  composer.render();
}
animate();
// === 你的原始代码结束 ===
</script>
</body>
</html>